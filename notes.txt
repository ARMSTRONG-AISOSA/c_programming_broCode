
||
||
||
index 1.0
<stdio.h>: contains useful function related to input and output
- std: standard
- i: input
- 0: output

<stdbool.h>: allows us work with booleans
<string.h>: allows us work with strings
<math.h>: allows us to use math functions
<ctype.h>: allows us to work with string functions
<stdlib.h>: allows memory allocation & deallocation

||
||
||
index 2.0
Escape Sequence = Character combo consisting of a backslash "\" followed by a letter or combo. of digits.
They Specify diff. actions.
    \n = newline
    \t = new tab


||
||
||
index 3.0
C only allows one main() function; 
C expects the entry point to be: int main()
Aynting in our "main" function is read procedurally, i.e top to bottom.
main() is the real entry point, and it calls your two other "helper" functions.

if you want to keep them separate functions for practice:
You can make them "normal helper functions" and call them from main() like this. ex "main01" & "main02"

i-3.1 Done also to check for errors.

||
||
||
index 4.0
variable = Allocated space in memory to store a value|
    We refer to a variable’s nane to access the stored value.
    That variable now behaves as if it was the value it contains.
    But we need to declare what type of data we are storing.
    Step 1: Declaration(integer) = int x;
    Step 2: Initialisation = x = 123;

||
||
||
index 5.0
*===== data types =====*
In C, data types define what kind of data a variable can hold — for example, integers, floating-point numbers, characters, etc.
int age = 123; //Integer
float gpa = 3.02; //Decimal point
double pie = 3.14159265; //Double-precision floating point 
    --> (more precise)	
char grade = 'c'; //single character 
    --> use single quote;

i-5.1
*===== derived data types =====*

*Type --> *Purpose
Array --> Collection of similar data types
Pointer --> Stores memory addresses
Structure(struct) --> Groups different types together
Union --> Like structure but shares memory
Function --> Block of code performing a task

ex.
char name[] = "Benson";//Array of characters 
    --> double quotes --> you emulate a sting
    -NB: C is not object oriented and "strings" are technically objects so you have to use an array to store multiple chracters

*===== enumeration type =====*
enum : Defines a set of named integer constants.
Ex.
enum days {Sunday, Monday, Tuesday}; 

*===== void type =====*
void : Means no value.
Used for functions that don't return anything.
Ex.
void sayHello() {
    printf("Hello!");
}

Size (Typical, but depends on system)
(Table)
Type	                      Size/memory
char	                      1 byte
short int                     2 bytes
int                           4 bytes
long long int                 8 bytes
float	                      4 bytes
double	                      8 bytes
bool                          1 byte

*===== modifiers =====*
You can further modify base types:
    -short, long (changes storage size)
    -signed, unsigned (whether it allows negative numbers)



*===== signed & unsigned data types =====*
In C, the difference between signed and unsigned data types is mainly about whether they can represent negative numbers.
    signed store Neg. and pos. numbers	-10 to 10
    unsigned only store pos. numbers (and zero)	0 to 20

Internally, the first bit (most significant bit) is used to indicate sign:
0 = positive
1 = negative

NB: 
    -Default for types like int, char (sometimes depends on compiler).
    -Since no bit is used for the sign, it can store larger positive values compared to signed types of the same size.

Signed types (e.g., signed int, signed char)
Unsigned types (e.g., unsigned int, unsigned char)


i-5.2
% ==> Format specifier/placeholder
In C programming, format specifiers are special symbols used with functions like printf() and scanf() to tell the compiler the type of data you're working with-like whether it’s an integer, a float, a character, etc.

NB: When you print or scan variables, you must match the right specifier with the data type, or you’ll get wrong output(garbage) or crashes.
ex.
int age = 25;
printf("I am %f years old.", age);

Here’s a list of some format specifiers in C:
Specifier	Data Type	                Example Value
%i	        int (integer)	            10
%d	        int (decimal integer)	    5
%u	        unsigned int	            20
%f	        float or double	            3.14
%.(n)f	    decimal precision   	    5.5
%lf         double	                    3.14159
%c	        char (character)	        'A'
%s	        string (char array)	        "Hello"
%p	        pointer address	            0x7ffeefbff5c0
%x / %X	    hexadecimal int         	0x1a
            (lowercase/uppercase)
%o	        octal integer	            0757
%e / %E	    scientific notation     	1.23e+02
            (float/double)

i-5.3
% ==> constantsThese are values and variables that cannot be altered by the program. Name conventions are all caps.
ex.
const float PI = 3.14159

||
||
||
index 6.0
// printf(): used for output display
// Scanf(): used to read input; cannot handle white space

i-6.01
& : this is an "address-of-operator"
why in scanf(), age is preceeded by an "&" and firstname is not.
    -scanf("%d", &age);
    -scanf("%s", firstName);

age is an int (a single number).
firstName is a string (an array of characters).

Why "&" for age?
scanf() needs the address of where to store the user's input in memory.
age is just a simple variable (a box), so you must give scanf() the address of that box by writing "&age."

Why no & for firstName?
firstName is already an address — it’s an array!
In C, the name of an array (like firstName) automatically acts as the address of its first element.

NB:
    -If it's a normal variable (like an int, float), you add &.
    -If it's an array (like char firstName[50]), you don't add & because the array itself acts as a pointer as the name is already an address.

i-6.1
code:
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF);
Purpose: It clears the input buffer — specifically, it discards any leftover characters (like the newline \n) in the buffer after using scanf().

When you use scanf() to read an int (like age), and the user presses Enter, a newline character (\n) remains in the input buffer. If you then use fgets() immediately afterward, it will read that leftover \n instead of the actual user input.

    -int ch;// Declare a variable to store characters.
    -while ((ch = getchar()) != '\n' //Keep reading characters until a newline is found
    -&& ch != EOF); //or end-of-file (just in case)

getchar() reads one character at a time from input buffer/stdin.
    -It assigns the character to ch.
    -It loops until it finds the newline character \n (user pressing Enter).
    -or it reaches end-of-file (EOF, typically when input is redirected or closed).
    -PS: getchar(), does not store the characters — it just consumes and discards them.


i-6.2
fgets(hobbies, 100, stdin);
fgets() is a C function used to read a line of text with spaces from an input stream.
    -fgets --> "file get string"
    -stdin – standard input (typically the keyboard).

Why use fgets() instead of scanf()?
    -scanf("%s", ...) stops reading at the first whitespace, so it won’t capture full names or phrases like "reading books".
    -fgets() reads the entire line (until Enter is pressed), including spaces.

ex.
If user types: Playing football and reading
fgets() will store the whole sentence, whereas scanf("%s", ...) would only store "Playing".

i-6.3 
Remove Trailing newline from fgets
#1
code:
    fgets(hobbies, 100, stdin);
    hobbies[strlen(hobbies)-1] = '\0';

This gets the length and removes the trailing newline character (\n) that fgets() usually stores at the end of the input string.
    -fgets() reads until a newline (\n) or the character limit is reached.
    -It includes the newline (\n) in the string, unless the user hits the exact character limit (rare).
    -strlen(hobbies) gets the length excluding the null terminator (\0)
    -This replaces the \n at the end with a null terminator, effectively trimming the newline.

From:
    -"Reading books\n\0"
To:
    -"Reading books\0"

For arrays
code:
    char fullNames[3][50]; 
    for (int i = 0; i < 3; i++)
    {
        fgets(fullNames[i], sizeof(fullNames[i]), stdin);
        // Remove trailing newline from fgets
        fullNames[i][strcspn(fullNames[i], "\n")] = '\0';
    }
    for (int i = 0; i < 3; i++)
    {
        printf("%s.\n",fullNames[i]);
    }

||
||
||
index 7.0
Whats the major difference between both
    *code:
    -void birthday(const char *name, int age) { //code }
    -void birthday(char name[], int age) { //code }

1. "const char *name"(Preferred for Read-Only Use)
const means "do not modify this string" inside the function.
This is safer and more expressive when your function is only supposed to use the name, not change it.

2. "char name[]" (Mutable)
Without const, the function is allowed to modify the contents of the name.
It's usually used when the function might change or update the string.


i-7.1 Arguments vs Parameters
When you call functions you can pass in arguments.
ex. birthday(name, age);

The involked(called) functions accept the arguments as paramenters.
Ps: parameters are what the function expects.
ex. void birthday(char name[], int age) { //code }

These communicate with each other across functions.


i-7.2 Return statement
When used it returns a value at the exact spot/call the function was called.

ps: also called functions define the data type being returned

"double" square(double x)
{
    double result x * x;
    return result;
}

i-7.3 Ternary operator
This is a shortcut to if/else statement when assigning/returning a value
    Syntax/Structure:
    (condition) ? value(if true) : value(if false)

i-7.3 Function prototype
A function prototype in C is a declaration of a function that tells the compiler:
    -The function's name
    -Its return type
    -The types of its parameters
It does not contain the body of the function — just the signature.

Syntax:
    return_type function_name(type1 param1, type2 param2, ...);
Code ex.
    void greetUser(char name[], int age);

Use?
-Ensures that calls to functions are made with the correct arguments
-Let the compiler know about the function before it's used. This avoids "implicit declaration" errors.
-Helps with type checking, ensuring you're passing correct argument types.
-Easier to navigate a program/multiple functions

Always place your prototypes above main() or in a header file (.h) when organizing larger projects.

i-7.3.1
OK to call before function(body) is defined: compiler already knows the function signature

||
||
||
index 8.0
for loop = repeats a section of code a limited amount of times

while loop = checks a condition, THEN executes a code if codition is true
    while loop = repeats a section of code possibly unlimited times
    Whiles some conditions are true
    a while loop might not execute

do while loop = always executes a block of code once, THEN checks a condition 


||
||
||
index 9.0
Array = a data structure that stores many value of the same data type
Arrays in C are stored CONTIGUOUSLY(side by side) in memory. 

/* code: */
    int numbers[5];
Array of 5 integers; this declares an array named numbers that can hold 5 integers.

Initializing Arrays
    int numbers[5] = {1, 2, 3, 4, 5};

You can also leave the size out and let the compiler count:
    int numbers[] = {1, 2, 3, 4, 5};

Accessing Elements
Array indexing starts at 0:
    printf("%d", numbers[0]);  // prints 1
    numbers[2] = 99;           // changes the third element

Array Types
-Integer array	        int nums[10];
-Float array	        float prices[5];
-Char array	char        name[20];
-2D array (matrix)	    int matrix[3][4];

Strings as Arrays
Strings in C are just arrays of characters ending with a null character \0.
    char name[] = "Ben";
is equivalent to:
    char name[] = {'B', 'e', 'n', '\0'};

Key Characteristics
Fixed size	            Cannot be resized once declared.
Homogeneous data	    All elements must be of the same type.
Continuous memory	    Stored in consecutive memory locations.
Indexing starts at 0	Always remember: first element is at index 0.
No bounds checking	    C does not warn you if you go out of bounds (can cause bugs).

Printing Arrays
C doesn't have a built-in way to print entire arrays at once.
So to print the entire array of prices in your code, you’ll need to loop through each element using a for loop

i-8.1
String Array (2D Array of Strings)
    const char *names[] = {"James", "Ken", "Tony"};
    printf("%s\n", names[0]);

const char *names[] is an array of string pointers (char *), each pointing to a string literal.

Another Example (Using a 2D Character Array)
    char names[3][10] = {
        "James",
        "Ken",
        "Tony"
    };
    printf("%s\n", names[0]);

Nb: The row size can be optional but the column size in important.

Explanation:
char names[3][10]: A 2D array that holds 3 strings, each with a maximum of 9 characters (+1 for the null terminator \0).


||
||
||
index 10.0

To make the for loop iteration condition dynamically update based on the number of items in the array, we calculate the amount of element in the array and loop that many times.

One way is to use the sizeof operator(It returns the size of an operand in bytes). 
NB: sizeof() returns a value of type size_t, which is an unsigned integer, not a floating-point number. Use "%zu" instead of %.1lf when printing values returned by sizeof.