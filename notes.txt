To comile the C file via terminal 
-cd into the folder and run
gcc 'filename' in the commandline
    --> gcc HelloWorld.c

To name the file yourself --> gcc HelloWorld.c -o helloWorld

To define the file & type --> gcc HelloWorld.c -o helloWorld(.exe/.out)

To run compiled file --> helloWorld.exe-- (linux)./helloWorld.exe

To run c in the terminal of vscode instead of the output, install "code runner", search for in settings and tick good to "run in terminal"

||
||
||
index 1.0
<stdio.h>: contains useful function related to input and output
- std: standard
- i: input
- 0: output

<stdbool.h>: added to work with booleans

||
||
||
index 2.0
Escape Sequence = Character combo consisting of a backslash "\" followed by a letter or combo. of digits.
They Specify diff. actions.
    \n = newline
    \t = new tab


||
||
||
index 3.0
C only allows one main() function; 
C expects the entry point to be: int main()
Aynting in our "main" function is read procedurally, i.e top to bottom.
main() is the real entry point, and it calls your two other "helper" functions.

if you want to keep them separate functions for practice:
You can make them "normal helper functions" and call them from main() like this. ex "main01" & "main02"

i-3.1 Done also to check for errors.

||
||
||
index 4.0
variable = Allocated space in memory to store a value|
    We refer to a variable’s nane to access the stored value.
    That variable now behaves as if it was the value it contains.
    But we need to declare what type of data we are storing.
    Step 1: Declaration(integer) = int x;
    Step 2: Initialisation = x = 123;

||
||
||
index 5.0
*===== data types =====*
In C, data types define what kind of data a variable can hold — for example, integers, floating-point numbers, characters, etc.
int age = 123; //Integer
float gpa = 3.02; //Decimal point
double pie = 3.14159265; //Double-precision floating point 
    --> (more precise)	
char grade = 'c'; //single character 
    --> use single quote;

i-5.1
*===== derived data types =====*

*Type --> *Purpose
Array --> Collection of similar data types
Pointer --> Stores memory addresses
Structure(struct) --> Groups different types together
Union --> Like structure but shares memory
Function --> Block of code performing a task

ex.
char name[] = "Benson";//Array of characters 
    --> double quotes --> you emulate a sting
    -NB: C is not object oriented and "strings" are technically objects so you have to use an array to store multiple chracters

*===== enumeration type =====*
enum : Defines a set of named integer constants.
Ex.
enum days {Sunday, Monday, Tuesday}; 

*===== void type =====*
void : Means no value.
Used for functions that don't return anything.
Ex.
void sayHello() {
    printf("Hello!");
}

Size (Typical, but depends on system)
(Table)
Type	                      Size/memory
char	                      1 byte
short int                     2 bytes
int                           4 bytes
long long int                 8 bytes
float	                      4 bytes
double	                      8 bytes
bool                          1 byte

*===== modifiers =====*
You can further modify base types:
    -short, long (changes storage size)
    -signed, unsigned (whether it allows negative numbers)



*===== signed & unsigned data types =====*
In C, the difference between signed and unsigned data types is mainly about whether they can represent negative numbers.
    signed store Neg. and pos. numbers	-10 to 10
    unsigned only store pos. numbers (and zero)	0 to 20

Internally, the first bit (most significant bit) is used to indicate sign:
0 = positive
1 = negative

NB: 
    -Default for types like int, char (sometimes depends on compiler).
    -Since no bit is used for the sign, it can store larger positive values compared to signed types of the same size.

Signed types (e.g., signed int, signed char)
Unsigned types (e.g., unsigned int, unsigned char)


i-5.2
% ==> Format specifier/placeholder
In C programming, format specifiers are special symbols used with functions like printf() and scanf() to tell the compiler the type of data you're working with-like whether it’s an integer, a float, a character, etc.

NB: When you print or scan variables, you must match the right specifier with the data type, or you’ll get wrong output(garbage) or crashes.
ex.
int age = 25;
printf("I am %f years old.", age);

Here’s a list of some format specifiers in C:
Specifier	Data Type	                Example Value
%i	        int (integer)	            10
%d	        int (decimal integer)	    5
%u	        unsigned int	            20
%f	        float or double	            3.14
%.(n)f	    decimal precision   	    5.5
%lf         double	                    3.14159
%c	        char (character)	        'A'
%s	        string (char array)	        "Hello"
%p	        pointer address	            0x7ffeefbff5c0
%x / %X	    hexadecimal int         	0x1a
            (lowercase/uppercase)
%o	        octal integer	            0757
%e / %E	    scientific notation     	1.23e+02
            (float/double)

i-5.3
% ==> constantsThese are values and variables that cannot be altered by the program. Name conventions are all caps.
ex.
const float PI = 3.14159

||
||
||
index 6.0
// printf(): used for output display
// Scanf(): used to read input; cannot handle white space

i-6.1
code:
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF);
Purpose: It clears the input buffer — specifically, it discards any leftover characters in the buffer after using scanf().

scanf() reads 25 but leaves the newline character (\n) in the input buffer.
That leftover newline would be picked up immediately by fgets() afterward, causing it to read an empty line.

    -int ch;// Declare a variable to store characters.
    -while ((ch = getchar()) != '\n' //Keep reading characters until a newline is found
    -&& ch != EOF); //or end-of-file (just in case)

getchar() reads one character at a time from stdin.
    -It loops until it finds the newline character \n (user pressing Enter).
    -It does not store the characters — it just consumes and discards them.


i-6.2
fgets(hobbies, 100, stdin);
fgets() is a C function used to read a line of text with spaces from an input stream.
    -fgets --> "file get string"
    -stdin – standard input (typically the keyboard).

Why use fgets() instead of scanf()?
    -scanf("%s", ...) stops reading at the first whitespace, so it won’t capture full names or phrases like "reading books".
    -fgets() reads the entire line (until Enter is pressed), including spaces.

ex.
If user types: Playing football and reading
fgets() will store the whole sentence, whereas scanf("%s", ...) would only store "Playing".

i-6.3
hobbies[strlen(hobbies)-1] = '\0';
This gets the length and removes the trailing newline character (\n) that fgets() usually stores at the end of the input string.
    -fgets() reads until a newline (\n) or the character limit is reached.
    -It includes the newline (\n) in the string, unless the user hits the exact character limit (rare).
    -strlen(hobbies) gets the length excluding the null terminator (\0)
    -This replaces the \n at the end with a null terminator, effectively trimming the newline.

From:
    -"Reading books\n\0"
To:
    -"Reading books\0"